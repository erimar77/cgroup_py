objects #prefixed with a crunch# shall be considered DONE


Will need several modules to handle the different bits n pieces, rather than one monolithic script. Ease of maintenance FTW.

Perhaps move to an object per-user rather than an object storing big-ol lists of users' data?

SEE ~/scratch/some_py_tests butt/stuff/things/run for a mechanism on sharing a data structure between modules


MODULES:
    DAEMON / MAIN.py:
        - Main loop, init, etc.
    
    OOMAILER.PY:
        - track eventfd on user OOM, send email.
        - start using python multiprocessing rather than subprocess.Popen? Seems to be a cleaner way.

    UTIL.PY:
        -various and sundry little methods for getting things did not directly coveredy by other modules.
            - fs work, bits n bobs
            - 

    GLOBALS.PY (possibly also cgconfig.py or similar):
        - Use a globals.py module to store stuff to be passed around between modules. DO NOT USE "from globals import $Variable", as this will just
        create a reference to that variable, but will NOT allow for modification of its value. Perhaps also use as a config file parser/storage tank?
        - methods
            - Parse config file!

        - fields / objects
            - dict to store users/cgroups for use across the application 
            - config vars / defaults! - maybe a class config()
            - dict for throttle data? (may be able to stuff this in the user/cgroup class)
            
    
    CPU.PY:
        - Low-level functions to grab CPU information for the system and for individual cgroups. Should NOT contain any logic to judge our
            init mode unless absolutely goddamn necessary.
        - Should then be used by class methods in USER.PY, etc to parse this data into usable structures.
        - methods
            - get system CPU information from /proc
                Return as list/dict?
                return delta? May be better to keep this as a var in globals and just modify / check against the damn thing as we go along.
            - pull cgroup totals from tasklist (agnostic of where this is coming from, just needs a list of PIDs)
                return just totals in jiffies or whatever? Leave the pct / delta to a method in user.py
            - write limit to cpu.cfs_quota_us pseudofile (take a cpu cgroup path)


    MEMORY.PY
        - Similar to CPU.PY: low-level functions to pull memory information and usage data
        - Functions to handle notification for memory usage?
        - methods
            - sendUsageNotification (usage_as_percent, userName/ID)
            - get system meminfo (numa nodes, total avail. ram)
            - get cgroup memusage via cgroup/memory.stat
                -  with and without cache
            - write limit to memory.(memsw).limit_in_bytes

    SOCKET.PY?
        - Set up a Unix socket to hold data for tracking status rather than writing this data to real files.

    USER.PY (OOOOH - maybe just cgroup.py? Make it agnostic to whether these are even user-based cgroups?)
        - Main chunk will be class user(), to contain data for each user's cgroup. Make initmode agnostic by simply storing
        direct paths for each subsystem used (cpu, cpuset, etc) rather than assuming specific mounts.
            - methods: 
                - for creating user cgroup if necessary
                - get CPU usage (time totals)
                - get CPU CHANGE and percentage
                - get memory usage
                - dump to file/socket (for monitoring)
                MAYBES
                    - set CPU limit - put logic to decide WHEN to limit elsewhere?
                        or just have a limit field, and use some external code to enforce it?
            - fields:
                - UID
                - UNAME
                - cpuset (as tuple? rather than using the "0-7" shortand, just a list of individual core IDs.
                    should allow for more complexity).
                - numa node(s) (expressed as above)
                - (cpu/memory/cpuset/etc) cgroup path ## Maybe a dict keyed by subsystem, but memory usage.
                - cpu total as float percentage of TOTAL usage. (expressed as 0-1 , .5 = 50% of all cores)
                - cpu total as time in jiffies or ns or whatever
                - cpu LIMIT (store here so we can allow for exception cases, or super-penalty boxing users)
                    - also keep a global max limit, put logic to decide WHEN to limit elsewhere
                - time under throttle and/or times throttled 
                    - pull from cgroup/cpu.stat or fudge numbers with x % of cpu limit?
                - memory total - RSS
                - memory total - Cached
                - memory total - Virt
                - currently-throttled bool (LEAVE SHOULD THROTTLE LOGIC TO SOME OTHER MODULE)
                - number of tasks
                
